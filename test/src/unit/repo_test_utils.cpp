/**
*  Copyright (C) 2024 3D Repo Ltd
*
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as
*  published by the Free Software Foundation, either version 3 of the
*  License, or (at your option) any later version.
*
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*
*  You should have received a copy of the GNU Affero General Public License
*  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "repo_test_utils.h"

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <gtest/gtest-matchers.h>
#include <time.h>

using namespace repo::core::model;
using namespace testing;

// Hidden pool of UUIDs for use by getRandUUID
std::vector<repo::lib::RepoUUID> uuidPool;
int uuidPoolCounter = 0;

repo::RepoController::RepoToken* testing::initController(repo::RepoController* controller) {
	std::string errMsg;
	return controller->init(errMsg, getConfig());
}

repo::lib::RepoVector3D testing::makeRepoVector()
{
	repo::lib::RepoVector3D v;
	v.x = (double)(rand() - rand()) / rand();
	v.y = (double)(rand() - rand()) / rand();
	v.z = (double)(rand() - rand()) / rand();
	return v;
}

std::vector<uint8_t> testing::makeRandomBinary(size_t size)
{
	std::vector<uint8_t> bin;
	for (int i = 0; i < size; i++)
	{
		bin.push_back(rand() % 256);
	}
	return bin;
}

repo::core::model::RepoBSON testing::makeRandomRepoBSON(int seed, size_t numBinFiles, size_t binFileSize)
{
	restartRand(seed);
	RepoBSONBuilder builder;

	// _id is the mongo primary key - if this isn't set then if this document gets
	// read back from the database it will have an autogenerated one and the
	// equality operator will return false.

	builder.append("_id", getRandUUID());

	int counter = 0;
	std::string prefix = std::string("field_");

	builder.append(prefix + std::to_string(counter++), std::to_string(rand()));
	builder.append(prefix + std::to_string(counter++), (int)rand());
	builder.append(prefix + std::to_string(counter++), (int64_t)rand());
	builder.append(prefix + std::to_string(counter++), (double)rand() / (double)rand());
	builder.append(prefix + std::to_string(counter++), (float)rand() / (double)rand());
	builder.append(prefix + std::to_string(counter++), getRandUUID());
	std::vector<float> matrixData;
	for (size_t i = 0; i < 16; i++)
	{
		matrixData.push_back(rand());
	}
	repo::lib::RepoMatrix m(matrixData);
	builder.append(prefix + std::to_string(counter++), m);
	builder.append(prefix + std::to_string(counter++), makeRepoVector());
	builder.appendVector3DObject(prefix + std::to_string(counter++), makeRepoVector());
	builder.append(prefix + std::to_string(counter++), getRandomTm());
	builder.append(prefix + std::to_string(counter++), rand() % 2 == 0);

	return builder.obj();
}

repo::core::model::RepoBSON testing::makeProjectSettings(const std::string& id)
{
	repo::core::model::RepoBSONBuilder settings;

	repo::core::model::RepoBSONBuilder properties;
	properties.append(REPO_PROJECT_SETTINGS_LABEL_UNITS, repo::lib::units::toUnitsString(repo::lib::ModelUnits::MILLIMETRES));

	settings.append(REPO_PROJECT_SETTINGS_LABEL_PROPERTIES, properties.obj());
	settings.append(REPO_LABEL_ID, id);
	settings.append(REPO_PROJECT_SETTINGS_LABEL_STATUS, "ok");

	return settings.obj();
}

repo::lib::RepoUUID testing::getRandUUID()
{
	if (!uuidPool.size()) {
		for (auto i = 0; i < 100000; i++) {
			uuidPool.push_back(repo::lib::RepoUUID::createUUID());
		}
	}
	return uuidPool[uuidPoolCounter++]; // Tests should not use more than 100000 UUIDs, but if so, this will throw
}

void testing::restartRand(int seed)
{
	std::srand(seed);
	uuidPoolCounter = seed;
}

bool testing::projectExists(
	const std::string& db,
	const std::string& project)
{
	auto handler = getHandler();
	for (auto collection : handler->getCollections(db)) {
		if (collection == (project + ".history")) {
			return true;
		}
	}
	return false;
}

bool testing::projectIsPopulated(
	const std::string& db,
	const std::string& project
)
{
	repo::RepoController* controller = new repo::RepoController();
	auto token = initController(controller);
	auto scene = controller->fetchScene(token, db, project);
	if (!scene) {
		return false;
	}
	if (!scene->hasRoot(repo::core::model::RepoScene::GraphType::DEFAULT)) {
		return false;
	}
	if (!scene->getAllMeshes(repo::core::model::RepoScene::GraphType::DEFAULT).size()) {
		return false;
	}
	if (!scene->getAllTransformations(repo::core::model::RepoScene::GraphType::DEFAULT).size()) {
		return false;
	}
	return true;
}

bool testing::projectSettingsCheck(
	const std::string& dbName, const std::string& projectName, const std::string& owner, const std::string& tag, const std::string& desc)
{
	bool res = false;
	repo::RepoController* controller = new repo::RepoController();
	auto token = initController(controller);

	if (token)
	{
		auto scene = controller->fetchScene(token, dbName, projectName, REPO_HISTORY_MASTER_BRANCH, true, true, true, { repo::core::model::ModelRevisionNode::UploadStatus::MISSING_BUNDLES });
		if (scene)
		{
			res = scene->getOwner() == owner && scene->getTag() == tag && scene->getMessage() == desc;
			delete scene;
		}
	}
	delete controller;
	return res;
}

bool testing::projectHasValidRevision(
	const std::string& dbName, const std::string& projectName)
{
	bool res = false;
	repo::RepoController* controller = new repo::RepoController();
	auto token = initController(controller);
	if (token)
	{
		auto scene = controller->fetchScene(token, dbName, projectName, REPO_HISTORY_MASTER_BRANCH, true, true);
		if (res = scene)
		{
			delete scene;
		}
	}
	delete controller;
	return res;
}

bool testing::fileExists(
	const std::string& file)
{
	std::ifstream ofs(file);
	const bool valid = ofs.good();
	ofs.close();
	return valid;
}

bool testing::filesCompare(
	const std::string& fileA,
	const std::string& fileB)
{
	bool match = false;
	std::ifstream fA(fileA), fB(fileB);
	if (fA.good() && fB.good())
	{
		std::string lineA, lineB;
		bool endofA, endofB;
		while ((endofA = (bool)std::getline(fA, lineA)) && (endofB = (bool)std::getline(fB, lineB)))
		{
			match = lineA == lineB;
			if (!match)
			{
				std::cout << "Failed match. " << std::endl;
				std::cout << "line A: " << lineA << std::endl;
				std::cout << "line B: " << lineB << std::endl;
				break;
			}
		}

		if (!endofA)
		{
			//if endofA is false then end of B won't be found as getline wouldn't have ran for fB
			endofB = (bool)std::getline(fB, lineB);
		}

		match &= (!endofA && !endofB);
	}

	return match;
}

bool testing::compareMaterialStructs(const repo::lib::repo_material_t& m1, const repo::lib::repo_material_t& m2)
{
	return m1.ambient == m2.ambient
		&& m1.diffuse == m2.diffuse
		&& m1.specular == m2.specular
		&& m1.emissive == m2.emissive
		&& m1.opacity == m2.opacity
		&& m1.shininess == m2.shininess
		&& m1.shininessStrength == m2.shininessStrength
		&& m1.lineWeight == m2.lineWeight
		&& m1.isWireframe == m2.isWireframe
		&& m1.isTwoSided == m2.isTwoSided;
}

std::string testing::getRandomString(const uint32_t& iLen)
{
	std::string sStr;
	sStr.reserve(iLen);
	char syms[] = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	unsigned int Ind = 0;
	srand(time(NULL) + rand());
	for (int i = 0; i < iLen; ++i);
	{
		sStr.push_back(syms[rand() % 62]);
	}

	return sStr;
}

bool testing::compareVectors(const repo::lib::repo_color4d_t& v1, const repo::lib::repo_color4d_t& v2)
{
	return v1.r == v2.r && v1.g == v2.g && v1.b == v2.b && v1.a == v2.a;
}

bool testing::compareVectors(const std::vector<repo::lib::repo_color4d_t>& v1, const std::vector<repo::lib::repo_color4d_t>& v2)
{
	if (v1.size() != v2.size()) return false;
	bool match = true;
	for (int i = 0; i < v1.size(); ++i)
	{
		match &= compareVectors(v1[i], v2[i]);
	}

	return match;
}

tm testing::getRandomTm()
{
	// Do this instead of building a tm struct directly, because the struct
	// has day entries etc that can be quite tricky to get right...
	time_t ten_years = 365 * 12 * 30 * 24 * 60;
	auto t = time(0) + ((time_t)rand() % ten_years) - ((time_t)rand() % ten_years);
	tm tm = *localtime(&t);
	return tm;
}

int testing::nFields(const repo::core::model::RepoBSON& bson)
{
	return bson.getFieldNames().size();
}

std::string produceCleanArgs(
	const std::string& database,
	const std::string& project,
	const std::string& dbAdd = REPO_GTEST_DBADDRESS,
	const int& port = REPO_GTEST_DBPORT,
	const std::string& username = REPO_GTEST_DBUSER,
	const std::string& password = REPO_GTEST_DBPW
)
{
	return  getClientExePath() + " "
		+ getConnConfig()
		+ " clean "
		+ database + " "
		+ project;
}

std::string testing::produceGenStashArgs(
	const std::string& database,
	const std::string& project,
	const std::string& type
)
{
	return  getClientExePath() + " "
		+ getConnConfig()
		+ " genStash "
		+ database + " "
		+ project + " "
		+ type;
}

std::string testing::produceGetFileArgs(
	const std::string& file,
	const std::string& database,
	const std::string& project
)
{
	return  getClientExePath() + " "
		+ getConnConfig()
		+ " getFile "
		+ database + " "
		+ project + " \""
		+ file + "\"";
}

std::string testing::produceCreateFedArgs(
	const std::string& file,
	const std::string& owner
)
{
	return  getClientExePath() + " "
		+ getConnConfig()
		+ " genFed \""
		+ file + "\" "
		+ owner;
}

std::string testing::produceUploadFileArgs(
	const std::string& filePath
) {
	return  getClientExePath() + " "
		+ getConnConfig()
		+ " import -f \""
		+ filePath + "\"";
}

std::string testing::produceProcessDrawingArgs(
	const std::string& filePath
)
{
	return  getClientExePath() + " "
		+ getConnConfig()
		+ " processDrawing \""
		+ filePath + "\"";
}

std::string testing::produceUploadArgs(
	const std::string& database,
	const std::string& project,
	const std::string& filePath,
	const std::string& configPath)
{
	return  getClientExePath()
		+ " " + configPath
		+ " import \""
		+ filePath + "\" "
		+ database + " " + project;
}

int testing::runProcess(
	const std::string& cmd)
{
	int status = system(cmd.c_str());
#ifndef _WIN32
	//Linux, use WIFEXITED(status) to get the real exit code
	return WEXITSTATUS(status);
#else
	return status;
#endif
}

void testing::setupTextures()
{
	//Upload RVT file with texture directory set
	std::string texturePath = "REPO_RVT_TEXTURES=" + getDataPath("textures");

	//Linux putenv takes in a char* instead of const char* - need a copy of the const char*
	char* texturePathEnv = new char[texturePath.size() + 1];
	strncpy(texturePathEnv, texturePath.c_str(), texturePath.size() + 1);

	putenv(texturePathEnv);
}

void testing::unsetupTextures()
{
#ifdef WIN32
	_putenv("REPO_RVT_TEXTURES=");
#else
	unsetenv("REPO_RVT_TEXTURES");
#endif // WIN32
}